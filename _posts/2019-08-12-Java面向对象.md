---
layout: post
title: "Java面向对象"
description: 同步日志Java面向对象相关知识
modified: 2019-08-12
category: Java
tags: [Java, 基础, 面向对象]
imagefeature:
mathjax: false
chart:
comments: false
featured: true
---

## 面向对象的思想

`面向过程`其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，每一个步骤中我们都是参与者。代表语言：C语言

> 面向过程 强调的是每一个功能的步骤  
> 面向对象 强调的是对象，然后由对象去调用功能  

`面向对象`:

1. 面向对象是基于面向过程的编程思想
2. 可以将复杂的事情简单化
3. 将我们从执行者变成指挥者

`面向对象开发`: 就是不断的创建对象，使用对象，指挥对象做事情  
`面向对象设计`：其实就是在管理和维护对象之间的关系  
`面向对象的特征`：封装、继承、多态  

## 类与对象及其使用

`类`:是一组相关的属性和行为的集合，是一个抽象的概念
`对象`:是该事物的具体表现形式，具体存在的个体

- 类的定义：
  - 成员变量：事物的属性
  - 成员方法：事物的行为

## 成员变量和局部变量的区别

- 在类中的位置不同
  - 成员变量在类中方法外
  - 局部变量在方法定义中或方法声明上
- 在内存中的位置不同
  - 成员变量在堆内存中
  - 局部变量在栈内存中
- 生命周期不同
  - 成员变量随着对象的创建而存在，随着对象的消失而消失
  - 局部变量随着方法的调用而存在，随着方法的调用完毕而消失
- 初始化值不同
  - 成员变量有默认初始化值
  - 局部变量没有默认初始值，必须定义、赋值，然后才能使用；

`注意事项:`局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。

## 匿名对象

`匿名对象`就是没有名字的对象。

- 应用场景：
  - 调用方法，仅仅只调用一次。 --匿名对象调用完毕后就是垃圾，可以被垃圾回收器回收。
  - 匿名对象可以作为实际参数传递

## 封装

`封装`:是指隐藏对象的属性和实现细节，仅对外提供公共的访问方式。

- 封装好处：
  - 隐藏实现细节，提供公共的访问方式
  - 提高了代码的复用性
  - 提高安全性
- 封装原则：
  - 将不需要对外提供的内容都隐藏起来
  - 把属性隐藏，提供公共方法对其访问

### private关键字

`private关键字`是一个权限修饰符。可以修饰成员（成员变量和成员方法），被private修饰的成员只能在本类中才能访问。

### this关键字

`this`是当前类的对象引用，它就代表当前类的一个对象。
哪个对象调用方法，this就代表哪个对象。

### 构造方法

`构造方法`：给对象的数据进行初始化

`构造方法格式`：
- 方法名和类名相同
- 方法没有返回值类型，连void都没有
- 没有具体的返回值

`构造方法的重载和注意事项：`
如果我们没有给出构造方法，系统将自动提供一个无参构造方法
如果我们给出了构造方，系统将不再提供默认的无参构造方法
构造方法可以重载，重载后依旧拥有初始化对象数据的能力

### 类的组成及成员方法的分类和使用

`类的组成`：成员变量、构造方法、成员方法

---

成员方法的分类：
- 根据返回值：
  - void类型
  - 非void类型
- 根据形式参数：
  - 空参方法
  - 非空参方法

### 创建对象的过程

1. 把需要创建对象的class文件加载到内存
2. 在栈内存中给对象对应的变量开辟一个空间
3. 在堆内存为对象申请一个空间
4. 给成员变量进行默认初始化
5. 给成员变量进行显示初始化
6. 数据初始化完成，然后把堆内存的地址值赋值给对象对应的变量

### static关键字

`static`可以修饰成员变量和方法  
`static`的特点：

- 随着类的加载而加载
- 优先于对象存在
- 被类的所有对象共享
- 可以通过类名直接调用

`static`的注意事项：

- 静态方法中是没有this关键字的
- 静态方法只能访问静态的成员变量和静态的成员方法

`静态变量`和`成员变量`的区别：

- 所属不同
  - 静态变量属于类，所以也称为类变量
  - 成员变量属于对象，所以也称为实例变量（对象变量）
- 内存中的位置不同
  - 静态变量存储在方法区的静态区
  - 成员变量存储在堆内存
- 内存出现的时间不同
  - 静态变量随着类的加载而加载，随着类的消失而消失
  - 成员变量随着对象的创建而存在，随着对象的消失而消失
- 调用不同
  - 静态变量可以通过类名调用，也可以通过对象调用
  - 成员变量只能通过对象调用

### 代码块

在Java中，使用{}括起来的代码被称为`代码块`。

分类：  
`局部代码块`：局部位置，用于限定变量的生命周期  
`构造代码块`：在类中的成员位置，每次调用构造方法执行前，都会先执行构造代码块。可以把多个构造方法中的共同代码放在一起。  
`静态代码块`：在类中的成员位置，用static修饰。在类加载时只执行一次，一般是对类进行初始化操作。  

静态代码块、构造代码块、构造方法的执行顺序？  
静态代码块  --  构造代码块  --  构造方法  
静态代码块只执行一次
构造代码块每次调用构造方法都会执行

## 继承

多个类中存在相同属性和行为时，将这写内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只需要继承那个类即可  

`继承`把多个类中相同的内容给提取出来定义到一个类中  
通过extends关键字可以实现类与类的继承  
单独的这个类称为父类、基类或者超类；这多个类可以称为子类或者派生类  

### 继承的好处：

- 提高了代码的复用性
- 提高了代码的维护性
- 让类与类之间产生了关系，是多态的前提

### JAVA中继承的特点：

- Java只支持单继承，不支持多继承
- Java中支持多层继承（继承体系）

### JAVA中继承的注意事项：

- 子类只能继承父类所有非私有的成员（成员方法和成员变量）
- 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类的构造方法
- 不要为了部分功能而去继承

什么时候考虑使用继承？  
采用假设法，如果两个类A、B，只要他们符合A是B的一种或者B是A的一种，就可以考虑使用继承。  
继承其实体现的是“is a”的关系。

### this和super的区别

- 分别是什么？
  - this代表本类对象的引用
  - super代表父类存储空间的标识（可以理解为父类的引用，可以操作父类的成员）
- 如何用？
  - 调用成员变量
  - 调用构造方法
  - 调用成员方法

说明：this(...)和super(...)在调构造的时候必须出现在第一条语句上。

### 继承中成员变量的关系

- 子类中的成员变量和父类中的成员变量名称不一样
- 子类中的成员变量和父类中的成员变量名称一样，就近原则

### 继承中构造方法的关系

- 子类中所有的构造方法默认都会走父类的无参构造

### 继承中成员方法的关系

- 子类中的方法和父类中的方法声明不一样
- 子类中的方法和父类中的方法声明一样，方法重写

### 方法重载和方法重写

`方法重载`：本来中出现的方法名一样，参数列表不同的方法，与返回值无关  
`方法重写`：子类中出现了和父类中方法声明一模一样的方法  

`方法重写的应用`：当子类需要父类的功能，而功能主体子类有自己特有的内容时，可以重写父类中的方法。这样，既沿袭了父类的功能，又定义了子类特有的内容。

### 方法重写的注意事项

- 父类中的私有方法不能被重写
- 子类重写父类方法时，访问权限不能更低
- 父类静态方法，子类必须通过静态方法进行重写
  - 其实这个算不上方法重写，但是现象确实如此，关注多态

## 多态

### final关键字

`final`:最终的意思，可以修饰类、方法、变量。

### final的特点

- final修饰类：  该类不能被继承
- final修饰方法：  该方法不能被重写
- final修饰变量：  该变量不能被重新赋值，引用类型地址值不能改变

### final修饰局部变量的问题

- 修饰基本类型：基本类型的值不能发生改变
- 修饰引用类型：引用类型的地址值不能发生改变，但是该对象堆内存的值是可以改变的

### final修饰变量的初始化时机

- 被final修饰的变量必须进行赋值且只能赋值一次
- 在构造方法之前进行初始化（非静态修饰）

### 多态的概述

`多态`是同一个事物，在不同时刻表现出来的不同状态。

### 多态的前提和体现

前提：

- 要有继承关系
- 要有方法重写
  - 没有也可以，但是没有的话没有意义
- 要有父类引用指向子类对象

体现：
Fu f = new Zi();

### 多态中的成员访问特点：

- 成员变量
  - 编译看左边，运行看左边
- 构造方法
  - 创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化
- 成员方法
  - 编译看左边，运行看右边
- 静态方法
  - 编译看左边，运行看左边

由于成员方法存在方法重写，所以运行看右边

### 多态的好处

- 提高了代码的维护性（继承保证）
- 提高了代码的扩展性（多态保证）

### 多态的弊端

- 不能使用子类的特有功能

解决办法：向下转型

## 抽象类

在Java中，一个没有方法体的方法应该定义为`抽象方法`
类中如果有抽象方法，必须定义为`抽象类`

### 抽象类的特点

- 抽象类和抽象方法必须用abstract关键字修饰
- 抽象类中不一定有抽象方法，但是有抽象方法的类必须定义为抽象类
- 抽象类不能实例化   因为他不是具体的
  - 抽象类有构造方法，但是不能实例化，构造方法用于子类访问父类数据的初始化
- 抽象类的子类
  - 如果不想重写抽象方法，该子类是一个抽象类
  - 重写所有的抽象方法，这个时候子类是一个具体的类

### 抽象类的成员特点

- 成员变量： 既可以是变量，也可以是常量
- 构造方法： 有构造方法，用于子类访问父类的数据初始化
- 成员方法： 既可以是抽象的，也可以是非抽象的

抽象类的成员方法特性：

- 抽象方法：强制要求子类做的事情
- 非抽象方法：子类继承的事情，提高代码复用性

### 抽象中的几个问题

- 一个类中没有抽象方法，可以定义为抽象类，这样做，不让外界创建对象
- 抽象abstract不能与哪些关键字共存
  - private 冲突，私有无法被重写，抽象需要被重写
  - final 冲突，class无法被重写，抽象需要被重写
  - static 无意义，类名调用没有方法体的方法无意义

## 接口

为了体现事物功能的扩展性，Java中提供了`接口`来定义这些额外功能，并不给具体实现，谁需要谁实现即可。

### 接口的特点

- 接口用关键字interface表示 
  - interface 接口名 {}
- 类实现接口用implements表示
  - class 类名 implements 接口名 {}
- 接口不能实例化
- 接口的子类
  - 可以是抽象类，但是没有意义
  - 可以是具体类，要重写接口中的所有抽象方法

### 接口成员变量的特点

- 成员变量：只能是常量，并且是静态的
  - 默认修饰符 public static final
- 构造方法：接口没有构造方法
- 成员方法：只能是抽象的
  - 默认修饰符 public abstract

### 类与类、类与接口、接口与接口的关系

- 类与类
  - 继承关系，只能单继承，可以多层继承。
- 类与接口
  - 实现关系，既可以单实现，也可以多实现。并且可以在继承一个类的同时实现多个接口。
- 接口与接口
  - 继承关系，可以单继承，也可以多继承。

### 抽象类和接口的区别

- 成员区别
  - 抽象类：
    - 成员变量：可以是变量，也可以是常量
    - 构造方法：有
    - 成员方法：可以是抽象的，也可以是非抽象的
  - 接口：
    - 成员变量：只可以是常量
    - 构造方法：没有
    - 成员方法：只可以是抽象
- 关系区别：
  - 类与类
    - 继承关系，只能单继承，可以多层继承。
  - 类与接口
    - 实现关系，既可以单实现，也可以多实现。并且可以在继承一个类的同时实现多个接口。
  - 接口与接口
    - 继承关系，可以单继承，也可以多继承。
- 设计理念区别
  - 抽象类
    - 体现“is a”的关系，抽象类中定义的是该继承体系的共性功能
  - 接口
    - 体现“like a”的关系，接口中定义的是该继承体系的扩展功能

### 形式参数和返回值的问题

- 形式参数
  - 基本类型
  - 引用类型
    - 类  需要的是该类的对象
    - 抽象类  需要的是该抽象类的子类对象
    - 接口  需要的是该接口的实现类对象

- 返回值类型
  - 基本类型
  - 引用类型
    - 类  返回的是该类的对象
    - 抽象类  返回的是该抽象类的子类对象
    - 接口  返回的是该接口的实现类对象

## 包

`包`其实就是文件夹  

- 包的作用：
  - 把相同的类名放在不同的包中
  - 对类进行分类管理

### 包的定义及注意事项

- 包的定义
  - package 报名;
  - 多级包用.分开即可
- 包的注意事项
  - package语句必须是成语的第一条可执行的代码
  - package语句在一个java文件中只能有一个
  - 如果没有package，默认表示无包名

### 导包

`导包`解决了不同报下类之间的访问问题

- 导包的格式
  - import 包名;
- 注意事项：
  - 这种方式导入的是到类的名称
  - 虽然可以最后写*，但是不建议

## 修饰符

### 权限修饰符

private、默认的、protected、public

|修饰符名   |本类|同一包下（子类和无关类）|不同包下（子类）|不同包下(无关类)|
|:--------:|:--:|:--:|:--:|:--:|
|private    |Y  |N|N|N|
|默认       |Y   |Y|N|N|
|protected  |Y  |Y|Y|N|
|public     |Y  |Y|Y|Y|

### 状态修饰符

static、final

### 抽象修饰符

abstract

### 修饰符使用

- 类
  - 权限修饰符：默认修饰符、public
  - 状态修饰符：final
  - 抽象修饰符：abstract
- 成员变量
  - 权限修饰符：private、默认、protected、public
  - 状态修饰符：static、final
- 构造方法
  - 权限修饰符：private、默认、protected、public
- 成员方法
  - 权限修饰符：private、默认、protected、public
  - 状态修饰符：static、final
  - 抽象修饰符：abstract

## 内部类

把类定义在其他类的内部，这个类就被称为`内部类`。  
  
- 内部类的访问特点：
  - 内部类可以直接访问外部类的成员，包括私有。
  - 外部类要想访问内部类，必须创建对象。
- 内部类的位置：
  - 成员位置  成员内部类：在成员位置定义的类被称为成员内部类
  - 局部位置  局部内部类：在局部位置定义的类被称为局部内部类

### 成员内部类

如何直接访问内部类的成员：
外部类名.内部类型 对象名 = 外部类对象.内部类对象;

成员内部类被静态修饰后的访问方式：
外部类名.内部类型 对象名 = 外部类对象.内部类名();

```java
{% raw %}
public class InnerClassTest {
    public static void main(String[] args) {
        Outer.Inner oi = new Outer().new Inner();
        oi.show();
    }
}

class Outer {
    public int num = 10;
    class Inner {
        public int num = 20;
        public void show() {
            int num = 30;
            System.out.println(num);
            System.out.println(this.num);
            //System.out.println(new Outer().num);
            System.out.println(Outer.this.num);
        }
    }
}
{% endraw %}
```

### 局部内部类

局部内部类：

1. 可以直接访问外部类的成员。
2. 在局部位置，可以创建内部类对象，通过对象调用内部类方法来使用局部内部类功能。

局部内部类访问局部变量的注意事项：  
必须使用final修饰。  
因为局部变量是随着方法的调用而调用，随着调用完毕而消失。而堆内存的内容（局部内部类）并不会立即消失，所以需要加final修饰。加入final修饰后，这个变量就成了常量。

### 匿名内部类

`匿名内部类`就是内部类的简化写法。

前提：存在一个类或者接口。
  这里的类可以是具体类也可以是抽象类。

格式：
new 类名或者接口名（） {
    重写方法；
}

本质是一个继承了该类或者实现了该接口的子类的匿名对象。